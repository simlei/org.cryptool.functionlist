#!/usr/bin/env python

import plumbum; from plumbum import local
import argparse
import sys
import subprocess
import flist_io as io
import typing; from typing import List, Dict, Any, Optional
import dataclasses; from dataclasses import dataclass, field
import pathlib; from pathlib import Path
import abc; from abc import ABC, abstractmethod

import flist_api as api
import flist_steps as steps
import flist_files
import workspace as ws
import logging
    
from plumbum.commands import BaseCommand

class FlistProg(ws.WSProg, api.Prog):

    def __init__(self):
        super().__init__()
        
        self.context.names["prog.logger"] = io.logger
        self.context.names["prog.args_pos"] = []
        self.context.names["params.workspace.template"] = Path(__file__).parent.parent / "ws-static"

        self.context_processors += [
            api.ContextProcessorYamlConfig(Path(__file__).parent.parent / "config.yaml")
        ]

        self.steps = []

        self.addStep(steps.FlistStep(
            name = "init_workspace",
            callable = lambda : self.ws.recreated(),
            proto = {}
        ))

        self.addStep(steps.CT2scsv_ct2_en)
        self.addStep(steps.CT2scsv_ct2_de)
        self.addStep(steps.CT2scsv_jct_en)
        self.addStep(steps.CT2scsv_jct_de)
        self.addStep(steps.categories_ct2_en)
        self.addStep(steps.categories_ct2_de)
        self.addStep(steps.categories_jct_en)
        self.addStep(steps.categories_jct_de)
        self.addStep(steps.merge_en)
        self.addStep(steps.merge_de)
        self.addStep(steps.tofinalform_en)
        self.addStep(steps.tofinalform_de)
        self.addStep(steps.tohtml_en)
        self.addStep(steps.tohtml_de)

    def runStep(self, step_name):
        step = self.context.names[f"step.{step_name}"] # type: steps.FlistStep
        step.perform()

    def addStep(self, step: steps.FlistStep, runByDefault=False):
        """
        Add a step to the program.
        Effectively, this registers a number of ContextProcessor instances that were made
        for the step, which work with the context w.r.t. to this step.
        
        The context will be populated with a set of dictionaries:
         - step.<stepname> -> the step object
         - config.step.<stepname> -> the config dictionary (yaml-parsed content) (string leafs)
         - params.step.<stepname> -> the parameters for invoking the step
        """

        # step.proto is assumed to only contain "empty" values so it can be used as template for
        # both config and params

        self.steps += [ step ]

        self.context.names[f"step.{step.name}"] = step
        self.context.names[f"config.step.{step.name}"] = step.proto.copy()
        self.context.names[f"params.step.{step.name}"] = step.proto.copy() # todo

        self.context_processors += step.get_config_proc();

    def Main(self):
        self.context.names["state.currentStep"] = "__main__"
        self.context.make_implicit("state.currentStep")

        mainLogger    = logging.getLogger("Flist:Main")   ; mainLogger.setLevel (logging.INFO)
        wslogLogger   = logging.getLogger("Flist:WSLog")  ; wslogLogger.setLevel(logging.INFO)
        consoleLogger = logging.getLogger("Flist:Console"); wslogLogger.setLevel(logging.INFO)

        mainLogger.addHandler(wslogLogger)
        mainLogger.addHandler(consoleLogger)
        consoleLogger.addHandler(logging.StreamHandler(sys.stderr))
        wslogLogger.addHandler(logging.FileHandler(self.ws.path / "log.txt"))

        self.context.names["prog.logger"] = mainLogger

        try:
            self.Main_Default()
        except io.FlistException as e:
            io.logFlistException(self.logger, e)
            exit(1)

    def Main_Default(self):
        for stepname in self.context.names["config.defaultsteps"]:
            self.context.names["state.currentStep"] = stepname
            self.runStep(stepname)


if __name__ == "__main__":
    prog = FlistProg()
    prog.run_from_cmdline_call(sys.argv[1:])

