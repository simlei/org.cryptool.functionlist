#!/usr/bin/env python

import plumbum; from plumbum import local
import argparse
import sys
import subprocess
import flist_io as io
import typing; from typing import List, Dict, Any, Optional
import dataclasses; from dataclasses import dataclass, field
import pathlib; from pathlib import Path
import abc; from abc import ABC, abstractmethod

import flist_api as api
import flist_steps as steps
import flist_files
import workspace as ws
import logging
    
from plumbum.commands import BaseCommand

class FlistProg(ws.WSProg, api.Prog):

    def __init__(self):
        super().__init__()
        
        SetupLogger = logging.getLogger("flist.Setup")
        SetupLogger.addFilter(FlistSetupLogFilter())
        self.context.names["prog.logger"] = SetupLogger

        self.context.names["prog.args_pos"] = []
        self.context.names["prog.logger"] = io.logger
        self.context.names["params.workspace.template"] = Path(__file__).parent.parent / "ws-static"

        self.context_processors += [
            api.ContextProcessorYamlConfig(Path(__file__).parent.parent / "config.yaml")
        ]

        self.steps = []
        self.steps_by_default = []

        self.addStep(steps.CT2scsv_ct2_en, runByDefault=True)
        self.addStep(steps.CT2scsv_ct2_de, runByDefault=True)
        self.addStep(steps.CT2scsv_jct_en, runByDefault=False)
        self.addStep(steps.CT2scsv_jct_de, runByDefault=False)
        self.addStep(steps.categories_ct2_en, runByDefault=False)
        self.addStep(steps.categories_ct2_de, runByDefault=False)
        self.addStep(steps.categories_jct_en, runByDefault=False)
        self.addStep(steps.categories_jct_de, runByDefault=False)
        self.addStep(steps.merge_en, runByDefault=False)
        self.addStep(steps.merge_de, runByDefault=False)
        self.addStep(steps.tofinalform_en, runByDefault=False)
        self.addStep(steps.tofinalform_de, runByDefault=False)
        self.addStep(steps.tohtml_en, runByDefault=False)
        self.addStep(steps.tohtml_de, runByDefault=False)

    def runStep(self, step_name):
        self.logger.info(f"Step {step_name} is being run")
        step = self.context.names[f"step.{step_name}"] # type: steps.FlistStep
        step.perform()

    def addStep(self, step: steps.FlistStep, runByDefault=False):
        """
        Add a step to the program.
        Effectively, this registers a number of ContextProcessor instances that were made
        for the step, which work with the context w.r.t. to this step.
        
        The context will be populated with a set of dictionaries:
         - step.<stepname> -> the step object
         - config.step.<stepname> -> the config dictionary (yaml-parsed content) (string leafs)
         - params.step.<stepname> -> the parameters for invoking the step
        """

        # step.proto is assumed to only contain "empty" values so it can be used as template for
        # both config and params

        self.steps += [ step ]
        if runByDefault:
            self.steps_by_default += [ step ]
        self.logger.debug(f"adding {step=}")
        self.context.names[f"step.{step.name}"] = step
        self.context.names[f"config.step.{step.name}"] = step.proto.copy()
        self.context.names[f"params.step.{step.name}"] = step.proto.copy() # todo
        self.logger.debug(f"set up step with config: {self.context.names['config.step.' + step.name]=}")
        self.context_processors += step.get_config_proc();

    def Main(self):
        self.ws.recreated()
        MainLogger = logging.getLogger("flist.Main")
        MainLogger.addFilter(FlistMainLogFilter())
        self.context.names["prog.logger"] = MainLogger

        for step in self.steps_by_default:
            self.runStep(step.name)


class FlistSetupLogFilter(logging.Filter):
    def filter(self, record):
        if record.levelname == "DEBUG":
            return False
        return True

class FlistMainLogFilter(logging.Filter):
    def filter(self, record):
        if record.levelname == "DEBUG":
            return False
        return True


logging.basicConfig(level=logging.INFO)
logging.getLogger("Prog::Default").addFilter(FlistSetupLogFilter())
prog = FlistProg()
prog.run_from_cmdline_call([])
